<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coding Assignment</title>

    <style>
      body {
        font-family: sf pro text, -apple-system, BlinkMacSystemFont, Roboto,
          segoe ui, Helvetica, Arial, sans-serif, apple color emoji,
          segoe ui emoji, segoe ui symbol;
        font-weight: 400;
        line-height: 22.4px;
        font-size: 16px;
      }
      p, ul, ol {
        font-size: 16px;
        font-weight: 400;
      }
      h1, h2, h3, h4, h5, h6 {
        font-weight: bold;
      }
      ul {
        list-style: none;
        margin: 0;
        padding: 0;
        max-width: none;
      }
      .code-snippet {
        background-color: #fff;
        border: 1px solid #d1d7dc;
        color: #b4690e;
        font-size: 90%;
        padding: 0.2rem 0.4rem;
      }
      .code-block {
        background-color: #fff;
        color: #b4690e;
        font-size: 90%;
      }
      .black-block {
        color: #000000;
      }
      .italic-text {
        font-style: italic;
      }
    </style>
  </head>

  <body onload="main()">
    <h1 id="coding-title"></h1>
    <div>
      <h2>Instructions</h2>
      <div id="coding-instructions"></div>
    </div>
    <div>
      <h2>Test(s)</h2>
      <div id="coding-tests"></div>
    </div>
    <div>
      <h2>Solution(s)</h2>
      <div id="coding-solutions"></div>
    </div>

    <script>
      const quizData = {"title": "004 DLL Swap Nodes in Pairs (  Interview Question)", "hasInstructions": true, "hasTests": true, "hasSolutions": true, "instructions": "<p><br><strong>ATTENTION: Advanced Doubly Linked List Challenge Ahead!<br><br></strong>This question is acknowledged as one of the more intricate challenges within the Doubly Linked List section. It's not unusual for students to find this task quite formidable at this point in the course.<br><br>If you're considering diving into this problem, it's crucial to approach it methodically. I recommend drawing out the list structures and operations to better visualize the problem. This challenge demands a deep understanding of Doubly Linked Lists' unique characteristics and manipulation techniques.<br><br>Use this opportunity to deepen your understanding, but also remember it's absolutely fine to come back to this problem later if it feels overwhelming now. Progress in complex concepts like these sometimes requires stepping back and revisiting with fresh insights. Good luck, and remember that perseverance is key in mastering these advanced topics!<br><br>Now, here is the problem:<br><br>_________________________________</p><p><br></p><p>Implement a member function called <code><strong>swapPairs()</strong></code> that swaps every two adjacent nodes of a doubly linked list.<br><br><strong>Note:</strong> <strong>This DoublyLinkedList does not have a tail pointer which will make the implementation easier.</strong></p><p><br></p><p>Output:</p><ul><li><p>The function should modify the doubly linked list in-place, swapping every two adjacent nodes.</p></li></ul><p><br></p><p>Constraints:</p><ul><li><p>You can only traverse the doubly linked list once.</p></li></ul><p><br></p><p><br></p><p>Example 1:</p><p>Suppose you have a DoublyLinkedList object, list, with the following values: <br>1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 4 &lt;-&gt; 5<br><br>After calling the <code><strong>swapPairs()</strong></code> function:</p><p><code><strong>list.swapPairs();</strong></code></p><p>The doubly linked list should now have the following values: <br>2 &lt;-&gt; 1 &lt;-&gt; 4 &lt;-&gt; 3 &lt;-&gt; 5</p><p><br></p><p><br></p><p>Example 2:</p><p>Now suppose you have a DoublyLinkedList object, list, with the following values: <br>3 &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; 4<br><br>After calling the <code><strong>swapPairs()</strong></code> function:</p><p><code><strong>list.swapPairs();</strong></code></p><p>The doubly linked list should now have the following values: <br>1 &lt;-&gt; 3 &lt;-&gt; 4 &lt;-&gt; 2</p><p><br></p><p><strong>Note:</strong> You must solve the problem <strong>WITHOUT MODIFYING THE VALUES</strong> in the list's nodes (i.e., only the nodes' prev and next pointers may be changed.)</p><p><br></p><p><br></p><p><img src=\"https://img-b.udemycdn.com/redactor/raw/coding_exercise_instructions/2023-05-02_19-57-11-68a210d25f03646ba84cc3e4a8fb278e.png\"></p>", "tests": [{"file_name": "evaluate.js", "content": "// Test 1: Swap an empty list\nit('should do nothing for an empty list', () => {\n  const dll = new DoublyLinkedList();\n  dll.makeEmpty();\n  dll.swapPairs();\n  expect(dll.length).toBe(0);\n  expect(dll.head).toBe(null);\n});\n\n// Test 2: Swap a single-element list\nit('should do nothing for a list with one element', () => {\n  const dll = new DoublyLinkedList(1);\n  dll.swapPairs();\n  expect(dll.head.value).toBe(1);\n});\n\n// Test 3: Swap a two-element list\nit('should swap two elements correctly', () => {\n  const dll = new DoublyLinkedList(1);\n  dll.push(2);\n  dll.swapPairs();\n  expect(dll.head.value).toBe(2);\n});\n\n// Test 4: Swap a three-element list\nit('should swap first two nodes in a list with three elements', () => {\n  const dll = new DoublyLinkedList(1);\n  dll.push(2);\n  dll.push(3);\n  dll.swapPairs();\n  expect(dll.head.value).toBe(2);\n  expect(dll.head.next.value).toBe(1);\n  expect(dll.head.next.next.value).toBe(3);\n});\n\n// Test 5: Swap a four-element list\nit('should swap all pairs in a list with four elements', () => {\n  const dll = new DoublyLinkedList(1);\n  dll.push(2);\n  dll.push(3);\n  dll.push(4);\n  dll.swapPairs();\n  expect(dll.head.value).toBe(2);\n  expect(dll.head.next.value).toBe(1);\n  expect(dll.head.next.next.value).toBe(4);\n  expect(dll.head.next.next.next.value).toBe(3);\n});\n\n// Test 6: Check length after swap\nit('should maintain the same length after swap', () => {\n  const dll = new DoublyLinkedList(1);\n  dll.push(2);\n  dll.push(3);\n  dll.swapPairs();\n  expect(dll.length).toBe(3);\n});\n\n// Test 7: Check head prev after swap\nit('should have null head.prev after swap', () => {\n  const dll = new DoublyLinkedList(1);\n  dll.push(2);\n  dll.swapPairs();\n  expect(dll.head.prev).toBe(null);\n});\n\n// Test 8: Check prev pointers after swap\nit('should update prev pointers correctly after swap', () => {\n  const dll = new DoublyLinkedList(1);\n  dll.push(2);\n  dll.push(3);\n  dll.push(4);\n  dll.swapPairs();\n  // Skip head and check the prev of the second node\n  expect(dll.head.next.prev.value).toBe(2);\n  expect(dll.head.next.next.prev.value).toBe(1);\n  expect(dll.head.next.next.next.prev.value).toBe(4);\n});\n\n// Test 9: Swap long list\nit('should swap a longer list correctly', () => {\n  const dll = new DoublyLinkedList(1);\n  dll.push(2);\n  dll.push(3);\n  dll.push(4);\n  dll.push(5);\n  dll.push(6);\n  dll.swapPairs();\n  expect(dll.head.value).toBe(2);\n  expect(dll.head.next.value).toBe(1);\n  expect(dll.head.next.next.value).toBe(4);\n  expect(dll.head.next.next.next.value).toBe(3);\n  expect(dll.head.next.next.next.next.value).toBe(6);\n  expect(dll.head.next.next.next.next.next.value).toBe(5);\n});\n\n// Test 10: Check length after swap on long list\nit('should maintain the same length after swap on long list', () => {\n  const dll = new DoublyLinkedList(1);\n  for(let i = 2; i <= 10; i++) {\n    dll.push(i);\n  }\n  dll.swapPairs();\n  expect(dll.length).toBe(10);\n});\n"}], "solutions": [{"file_name": "index.js", "content": "class Node {\n    constructor(value){\n        this.value = value;\n        this.next = null;\n        this.prev = null;\n    }\n}\n \nclass DoublyLinkedList {\n    constructor(value) {\n        const newNode = new Node(value);\n        this.head = newNode;\n        this.length = 1;\n    }\n\n    printList() {\n        let temp = this.head;\n        while (temp !== null) {\n            console.log(temp.value);\n            temp = temp.next;\n        }\n    }\n\n    getHead() {\n        if (this.head === null) {\n            console.log(\"Head: null\");\n        } else {\n            console.log(\"Head: \" + this.head.value);\n        }\n    }\n\n    getLength() {\n        console.log(\"Length: \" + this.length);\n    }\n\n    makeEmpty() {\n        this.head = null;\n        this.length = 0;\n    }\n \n    push(value) {\n        const newNode = new Node(value);\n        if (this.length === 0) {\n            this.head = newNode;\n        } else {\n            let currentNode = this.head;\n            while (currentNode.next !== null) {\n                currentNode = currentNode.next;\n            }\n            currentNode.next = newNode;\n            newNode.prev = currentNode;\n        }\n        this.length++;\n    }\n    \n    swapPairs() {\n        const dummy = new Node(0);\n        dummy.next = this.head;\n        let prev = dummy;\n\n        while (this.head !== null && this.head.next !== null) {\n            const firstNode = this.head;\n            const secondNode = this.head.next;\n\n            prev.next = secondNode;\n            firstNode.next = secondNode.next;\n            secondNode.next = firstNode;\n\n            secondNode.prev = prev;\n            firstNode.prev = secondNode;\n            if (firstNode.next !== null) {\n                firstNode.next.prev = firstNode;\n            }\n\n            this.head = firstNode.next;\n            prev = firstNode;\n        }\n\n        this.head = dummy.next;\n        if (this.head) this.head.prev = null;\n    }\n\n}"}]};

      function renderCodeList(rootElement, codeList, className, titlePrefix) {
        for (var i = 0; i < codeList.length; i++) {
          var elem = codeList[i];
          var jsElem = document.createElement("div");
          jsElem.className = className;
          var jsElemTitle = document.createElement("h3");
          jsElemTitle.innerHTML = titlePrefix + " " + (i + 1);
          var jsElemBody = document.createElement("code");
          jsElemBody.className = "code-block black-block";
          jsElemBody.innerHTML = "<pre>" + elem.content + "</pre>";
          jsElem.appendChild(jsElemTitle);
          jsElem.appendChild(jsElemBody);
          rootElement.appendChild(jsElem);
        }
      }
      
      function main() {
        // display the assignment
        var codingTitle = document.getElementById("coding-title");
        codingTitle.innerHTML = quizData.title;
        
        var codingInstructions = document.getElementById("coding-instructions");
        if (quizData.hasInstructions) {
          codingInstructions.innerHTML = quizData.instructions;
        } else {
          codingInstructions.innerHTML = "<span class=\"italic-text\">" + quizData.instructions
            + "</span>";
        }

        // display the test(s)
        var codingTests = document.getElementById("coding-tests");
        if (!quizData.hasTests) {
          codingTests.innerHTML = "<span class=\"italic-text\">" + quizData.tests + "</span>";
        } else {
          renderCodeList(codingTests, quizData.tests, "coding-test", "Test");
        }
        

        // display the solution(s)
        var codingSolutions = document.getElementById("coding-solutions");
        if (!quizData.hasSolutions) {
          codingSolutions.innerHTML = "<span class=\"italic-text\">" + quizData.solutions + "</span>";
        } else {
          renderCodeList(codingSolutions, quizData.solutions, "coding-solution", "Solution");
        }
      }
    </script>
  </body>
</html>
