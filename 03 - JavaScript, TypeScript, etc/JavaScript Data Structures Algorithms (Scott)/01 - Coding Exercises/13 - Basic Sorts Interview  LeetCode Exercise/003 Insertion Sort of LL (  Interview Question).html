<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coding Assignment</title>

    <style>
      body {
        font-family: sf pro text, -apple-system, BlinkMacSystemFont, Roboto,
          segoe ui, Helvetica, Arial, sans-serif, apple color emoji,
          segoe ui emoji, segoe ui symbol;
        font-weight: 400;
        line-height: 22.4px;
        font-size: 16px;
      }
      p, ul, ol {
        font-size: 16px;
        font-weight: 400;
      }
      h1, h2, h3, h4, h5, h6 {
        font-weight: bold;
      }
      ul {
        list-style: none;
        margin: 0;
        padding: 0;
        max-width: none;
      }
      .code-snippet {
        background-color: #fff;
        border: 1px solid #d1d7dc;
        color: #b4690e;
        font-size: 90%;
        padding: 0.2rem 0.4rem;
      }
      .code-block {
        background-color: #fff;
        color: #b4690e;
        font-size: 90%;
      }
      .black-block {
        color: #000000;
      }
      .italic-text {
        font-style: italic;
      }
    </style>
  </head>

  <body onload="main()">
    <h1 id="coding-title"></h1>
    <div>
      <h2>Instructions</h2>
      <div id="coding-instructions"></div>
    </div>
    <div>
      <h2>Test(s)</h2>
      <div id="coding-tests"></div>
    </div>
    <div>
      <h2>Solution(s)</h2>
      <div id="coding-solutions"></div>
    </div>

    <script>
      const quizData = {"title": "003 Insertion Sort of LL (  Interview Question)", "hasInstructions": true, "hasTests": true, "hasSolutions": true, "instructions": "<p>Write&nbsp; <code><strong>insertionSort()</strong></code> method that sorts a singly linked list in ascending order using the Insertion Sort algorithm. The method should take no input arguments. <br><br>The <code><strong>insertionSort()</strong></code> method should sort the linked list in place by repeatedly inserting each unsorted node into its correct position in the sorted part of the list.&nbsp; If the length of the linked list is less than 2, the method should simply return because the list is already sorted.&nbsp; After the sort, the method should update the head and tail pointers of the linked list to point to the first and last nodes, respectively.<br><br>The implementation should start with a <code><strong>sortedListHead</strong></code> variable that initially points to the head of the list, and a <code><strong>unsortedListHead</strong></code> variable that initially points to the second node in the list (if it exists).&nbsp; The method should then iterate through the unsorted part of the list and insert each node into its correct position in the sorted part of the list.<br><br>If a node in the unsorted part of the list is less than the head of the sorted part of the list, it should become the new head of the sorted list. Otherwise, the method should iterate through the sorted part of the list using a <code><strong>searchPointer</strong></code> variable until it finds the correct position to insert the node.&nbsp; The node should then be inserted into the sorted list by updating the <code><strong>next</strong></code> reference of the previous node to point to the new node, and the <code><strong>next</strong></code> reference of the new node to point to the next node in the sorted part of the list.</p><p><br></p><p><br></p><p><img src=\"https://img-b.udemycdn.com/redactor/raw/coding_exercise_instructions/2023-07-20_16-56-21-d7dfb7b1cbdc9eb866dd00895bf295c4.png\"></p><p><br></p><p><br></p><p><br></p>", "tests": [{"file_name": "evaluate.js", "content": "// Helper function to convert linked list to an array\nfunction linkedListToArray(list) {\n    const arr = [];\n    let current = list.head;\n    while (current !== null) {\n        arr.push(current.value);\n        current = current.next;\n    }\n    return arr;\n}\n\n// Test #1: Sorts a list with multiple items\nit('should sort a list with multiple items', () => {\n    const list = new LinkedList(5);\n    list.push(4);\n    list.push(3);\n    list.push(2);\n    list.push(1);\n    list.insertionSort();\n    expect(linkedListToArray(list)).toEqual([1, 2, 3, 4, 5]);\n});\n\n// Test #2: Sorts a list with negative numbers\nit('should sort a list with negative numbers', () => {\n    const list = new LinkedList(1);\n    list.push(-1);\n    list.push(3);\n    list.push(-2);\n    list.insertionSort();\n    expect(linkedListToArray(list)).toEqual([-2, -1, 1, 3]);\n});\n\n// Test #3: Sorts a list with a single item\nit('should handle a list with a single item', () => {\n    const list = new LinkedList(1);\n    list.insertionSort();\n    expect(linkedListToArray(list)).toEqual([1]);\n});\n\n// Test #4: Sorts an empty list\nit('should handle an empty list', () => {\n    const list = new LinkedList(1);\n    list.makeEmpty();\n    list.insertionSort();\n    expect(linkedListToArray(list)).toEqual([]);\n});\n\n// Test #5: Sorts a list with duplicate items\nit('should sort a list with duplicate items', () => {\n    const list = new LinkedList(3);\n    list.push(1);\n    list.push(2);\n    list.push(1);\n    list.push(2);\n    list.insertionSort();\n    expect(linkedListToArray(list)).toEqual([1, 1, 2, 2, 3]);\n});\n\n// Test #6: Sorts a list with already sorted items\nit('should handle a list with already sorted items', () => {\n    const list = new LinkedList(1);\n    list.push(2);\n    list.push(3);\n    list.push(4);\n    list.insertionSort();\n    expect(linkedListToArray(list)).toEqual([1, 2, 3, 4]);\n});\n\n// Test #7: Sorts a list with items in descending order\nit('should sort a list with items in descending order', () => {\n    const list = new LinkedList(5);\n    list.push(4);\n    list.push(3);\n    list.push(2);\n    list.push(1);\n    list.insertionSort();\n    expect(linkedListToArray(list)).toEqual([1, 2, 3, 4, 5]);\n});\n\n// Test #8: Sorts a list with all the same items\nit('should handle a list with all the same items', () => {\n    const list = new LinkedList(1);\n    list.push(1);\n    list.push(1);\n    list.push(1);\n    list.insertionSort();\n    expect(linkedListToArray(list)).toEqual([1, 1, 1, 1]);\n});\n\n\n"}], "solutions": [{"file_name": "index.js", "content": "class Node {\n    constructor(value){\n        this.value = value;\n        this.next = null;\n    }\n}\n \nclass LinkedList {\n    constructor(value) {\n        const newNode = new Node(value);\n        this.head = newNode;\n        this.tail = this.head;\n        this.length = 1;\n    }\n\n    printList() {\n        let temp = this.head;\n        let output = \"\";\n        if (temp === null) {\n            console.log(\"empty\");\n            return;\n        }\n        while (temp !== null) {\n            output += String(temp.value);\n            temp = temp.next;\n            if (temp !== null) {\n                output += \" -> \";\n            }\n        }\n        console.log(output);\n    }\n\n    makeEmpty() {\n        this.head = null;\n        this.tail = null;\n        this.length = 0;\n    }\n    \n    push(value) {\n        const newNode = new Node(value);\n        if (!this.head) {\n            this.head = newNode;\n            this.tail = newNode;\n        } else {\n            this.tail.next = newNode;\n            this.tail = newNode;\n        }\n        this.length++;\n        return this;\n    }\n    \n    insertionSort() {\n        if (this.length < 2) {\n            return; // List is already sorted\n        }\n    \n        let sortedListHead = this.head;\n        let unsortedListHead = this.head.next;\n        sortedListHead.next = null;\n    \n        while (unsortedListHead !== null) {\n            let current = unsortedListHead;\n            unsortedListHead = unsortedListHead.next;\n    \n            if (current.value < sortedListHead.value) {\n                current.next = sortedListHead;\n                sortedListHead = current;\n            } else {\n                let searchPointer = sortedListHead;\n                while (searchPointer.next !== null && current.value > searchPointer.next.value) {\n                    searchPointer = searchPointer.next;\n                }\n                current.next = searchPointer.next;\n                searchPointer.next = current;\n            }\n        }\n    \n        this.head = sortedListHead;\n        let temp = this.head;\n        while (temp.next !== null) {\n            temp = temp.next;\n        }\n        this.tail = temp;\n    }\n\t\n}\n\n\n\n\n\n// ------------------------------------\n//  Sort descending list\n// ------------------------------------\nconst list1 = new LinkedList(4);\nlist1.push(3);\nlist1.push(2);\nlist1.push(1);\nconsole.log(\"Sort descending list:\");\nlist1.printList(); // Should print: 4 -> 3 -> 2 -> 1\nlist1.insertionSort();\nlist1.printList(); // Should print: 1 -> 2 -> 3 -> 4\nconsole.log(\"---------------\");\n\n// ------------------------------------\n//  Sort already sorted list\n// ------------------------------------\nconst list2 = new LinkedList(1);\nlist2.push(2);\nconsole.log(\"Sort already sorted list:\");\nlist2.printList(); // Should print: 1 -> 2\nlist2.insertionSort();\nlist2.printList(); // Should print: 1 -> 2\nconsole.log(\"---------------\");\n\n// ------------------------------------\n//  Sort list with random elements\n// ------------------------------------\nconst list3 = new LinkedList(3);\nlist3.push(1);\nlist3.push(4);\nlist3.push(2);\nconsole.log(\"Sort list with random elements:\");\nlist3.printList(); // Should print: 3 -> 1 -> 4 -> 2\nlist3.insertionSort();\nlist3.printList(); // Should print: 1 -> 2 -> 3 -> 4\nconsole.log(\"---------------\");\n\n// ------------------------------------\n//  Sort list with duplicate elements\n// ------------------------------------\nconst list4 = new LinkedList(3);\nlist4.push(3);\nlist4.push(2);\nlist4.push(2);\nconsole.log(\"Sort list with duplicate elements:\");\nlist4.printList(); // Should print: 3 -> 3 -> 2 -> 2\nlist4.insertionSort();\nlist4.printList(); // Should print: 2 -> 2 -> 3 -> 3\nconsole.log(\"---------------\");\n\n// ------------------------------------\n//  Sort single-element list\n// ------------------------------------\nconst list5 = new LinkedList(1);\nconsole.log(\"Sort single-element list:\");\nlist5.printList(); // Should print: 1\nlist5.insertionSort();\nlist5.printList(); // Should print: 1\nconsole.log(\"---------------\");\n\n// ------------------------------------\n//  Sort list with negative numbers\n// ------------------------------------\nconst list6 = new LinkedList(-1);\nlist6.push(-2);\nlist6.push(1);\nconsole.log(\"Sort list with negative numbers:\");\nlist6.printList(); // Should print: -1 -> -2 -> 1\nlist6.insertionSort();\nlist6.printList(); // Should print: -2 -> -1 -> 1\nconsole.log(\"---------------\");\n\n// ------------------------------------\n//  Sort list with zeros\n// ------------------------------------\nconst list7 = new LinkedList(0);\nlist7.push(0);\nlist7.push(1);\nconsole.log(\"Sort list with zeros:\");\nlist7.printList(); // Should print: 0 -> 0 -> 1\nlist7.insertionSort();\nlist7.printList(); // Should print: 0 -> 0 -> 1\nconsole.log(\"---------------\");\n\n// ------------------------------------\n//  Sort empty list\n// ------------------------------------\nconst list8 = new LinkedList(1);\nlist8.makeEmpty();\nconsole.log(\"Sort empty list:\");\nlist8.printList(); // Should print: empty\nlist8.insertionSort();\nlist8.printList(); // Should print: empty\nconsole.log(\"---------------\");\n\n\n"}]};

      function renderCodeList(rootElement, codeList, className, titlePrefix) {
        for (var i = 0; i < codeList.length; i++) {
          var elem = codeList[i];
          var jsElem = document.createElement("div");
          jsElem.className = className;
          var jsElemTitle = document.createElement("h3");
          jsElemTitle.innerHTML = titlePrefix + " " + (i + 1);
          var jsElemBody = document.createElement("code");
          jsElemBody.className = "code-block black-block";
          jsElemBody.innerHTML = "<pre>" + elem.content + "</pre>";
          jsElem.appendChild(jsElemTitle);
          jsElem.appendChild(jsElemBody);
          rootElement.appendChild(jsElem);
        }
      }
      
      function main() {
        // display the assignment
        var codingTitle = document.getElementById("coding-title");
        codingTitle.innerHTML = quizData.title;
        
        var codingInstructions = document.getElementById("coding-instructions");
        if (quizData.hasInstructions) {
          codingInstructions.innerHTML = quizData.instructions;
        } else {
          codingInstructions.innerHTML = "<span class=\"italic-text\">" + quizData.instructions
            + "</span>";
        }

        // display the test(s)
        var codingTests = document.getElementById("coding-tests");
        if (!quizData.hasTests) {
          codingTests.innerHTML = "<span class=\"italic-text\">" + quizData.tests + "</span>";
        } else {
          renderCodeList(codingTests, quizData.tests, "coding-test", "Test");
        }
        

        // display the solution(s)
        var codingSolutions = document.getElementById("coding-solutions");
        if (!quizData.hasSolutions) {
          codingSolutions.innerHTML = "<span class=\"italic-text\">" + quizData.solutions + "</span>";
        } else {
          renderCodeList(codingSolutions, quizData.solutions, "coding-solution", "Solution");
        }
      }
    </script>
  </body>
</html>
