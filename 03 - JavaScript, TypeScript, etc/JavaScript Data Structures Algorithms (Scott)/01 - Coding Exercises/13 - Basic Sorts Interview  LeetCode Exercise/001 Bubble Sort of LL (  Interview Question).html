<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coding Assignment</title>

    <style>
      body {
        font-family: sf pro text, -apple-system, BlinkMacSystemFont, Roboto,
          segoe ui, Helvetica, Arial, sans-serif, apple color emoji,
          segoe ui emoji, segoe ui symbol;
        font-weight: 400;
        line-height: 22.4px;
        font-size: 16px;
      }
      p, ul, ol {
        font-size: 16px;
        font-weight: 400;
      }
      h1, h2, h3, h4, h5, h6 {
        font-weight: bold;
      }
      ul {
        list-style: none;
        margin: 0;
        padding: 0;
        max-width: none;
      }
      .code-snippet {
        background-color: #fff;
        border: 1px solid #d1d7dc;
        color: #b4690e;
        font-size: 90%;
        padding: 0.2rem 0.4rem;
      }
      .code-block {
        background-color: #fff;
        color: #b4690e;
        font-size: 90%;
      }
      .black-block {
        color: #000000;
      }
      .italic-text {
        font-style: italic;
      }
    </style>
  </head>

  <body onload="main()">
    <h1 id="coding-title"></h1>
    <div>
      <h2>Instructions</h2>
      <div id="coding-instructions"></div>
    </div>
    <div>
      <h2>Test(s)</h2>
      <div id="coding-tests"></div>
    </div>
    <div>
      <h2>Solution(s)</h2>
      <div id="coding-solutions"></div>
    </div>

    <script>
      const quizData = {"title": "001 Bubble Sort of LL (  Interview Question)", "hasInstructions": true, "hasTests": true, "hasSolutions": true, "instructions": "<p>Implement the bubble sort algorithm in a singly linked list. <br><br>The linked list will contain integer elements.<br><br>You need to write a method <code><strong>bubbleSort()</strong></code> within the LinkedList class. This method will sort the linked list in ascending order using the Bubble Sort algorithm.<br><br>The Bubble Sort algorithm works by comparing each pair of adjacent elements in the list and swapping them if they are in the wrong order. The pass through the list is repeated until the list is sorted.<br><br>Here is a brief overview of the steps involved in implementing the bubble sort algorithm:</p><ol><li><p>Check if the length of the linked list is less than 2. If it is, the list is already sorted, so the method should return immediately.</p></li><li><p>Initialize a Node object <code><strong>sortedUntil</strong></code> to null. This will act as a marker to the end of the sorted portion of the list.</p></li><li><p>Set up a while loop that continues as long as <code><strong>sortedUntil</strong></code> does not equal the second node in the list (<code><strong>this.head.next</strong></code>).</p></li><li><p>Within this loop, start from the head of the list and compare the value of the current node with the value of the next node.</p></li><li><p>If the value of the current node is greater than the value of the next node, swap the values.</p></li><li><p>Continue comparing and swapping until you reach the node before <code><strong>sortedUntil</strong></code>.</p></li><li><p>At the end of each pass through the list, set <code><strong>sortedUntil</strong></code> to the last node that was examined. This marks the end of the sorted portion of the list and the start of the unsorted portion for the next pass.</p></li><li><p>The algorithm continues until the list is fully sorted.</p></li></ol><p><br></p><p>Please make sure your code follows the above steps to implement the bubble sort method correctly.<br><br>You may assume that all values in the list are integers. Also, please note that your <code><strong>bubbleSort()</strong></code> method should not return any value; it should sort the linked list in-place. That is, it should modify the original linked list rather than creating and returning a new, sorted list.</p><p><br></p><p><br></p><p><img src=\"https://img-b.udemycdn.com/redactor/raw/coding_exercise_instructions/2023-07-20_17-15-48-8c6bd74ea4ce508c43975c02b3744ca8.png\"></p><p><br></p><p><br></p>", "tests": [{"file_name": "evaluate.js", "content": "// Helper function to convert linked list to an array\nfunction linkedListToArray(list) {\n    const arr = [];\n    let current = list.head;\n    while (current !== null) {\n        arr.push(current.value);\n        current = current.next;\n    }\n    return arr;\n}\n\n// Test #1: Sorts a list with multiple items\nit('should sort a list with multiple items', () => {\n    const list = new LinkedList(5);\n    list.push(4);\n    list.push(3);\n    list.push(2);\n    list.push(1);\n    list.bubbleSort();\n    expect(linkedListToArray(list)).toEqual([1, 2, 3, 4, 5]);\n});\n\n// Test #2: Sorts a list with negative numbers\nit('should sort a list with negative numbers', () => {\n    const list = new LinkedList(1);\n    list.push(-1);\n    list.push(3);\n    list.push(-2);\n    list.bubbleSort();\n    expect(linkedListToArray(list)).toEqual([-2, -1, 1, 3]);\n});\n\n// Test #3: Sorts a list with a single item\nit('should handle a list with a single item', () => {\n    const list = new LinkedList(1);\n    list.bubbleSort();\n    expect(linkedListToArray(list)).toEqual([1]);\n});\n\n// Test #4: Sorts an empty list\nit('should handle an empty list', () => {\n    const list = new LinkedList(1);\n    list.makeEmpty();\n    list.bubbleSort();\n    expect(linkedListToArray(list)).toEqual([]);\n});\n\n// Test #5: Sorts a list with duplicate items\nit('should sort a list with duplicate items', () => {\n    const list = new LinkedList(3);\n    list.push(1);\n    list.push(2);\n    list.push(1);\n    list.push(2);\n    list.bubbleSort();\n    expect(linkedListToArray(list)).toEqual([1, 1, 2, 2, 3]);\n});\n\n// Test #6: Sorts a list with already sorted items\nit('should handle a list with already sorted items', () => {\n    const list = new LinkedList(1);\n    list.push(2);\n    list.push(3);\n    list.push(4);\n    list.bubbleSort();\n    expect(linkedListToArray(list)).toEqual([1, 2, 3, 4]);\n});\n\n// Test #7: Sorts a list with items in descending order\nit('should sort a list with items in descending order', () => {\n    const list = new LinkedList(5);\n    list.push(4);\n    list.push(3);\n    list.push(2);\n    list.push(1);\n    list.bubbleSort();\n    expect(linkedListToArray(list)).toEqual([1, 2, 3, 4, 5]);\n});\n\n// Test #8: Sorts a list with all the same items\nit('should handle a list with all the same items', () => {\n    const list = new LinkedList(1);\n    list.push(1);\n    list.push(1);\n    list.push(1);\n    list.bubbleSort();\n    expect(linkedListToArray(list)).toEqual([1, 1, 1, 1]);\n});\n\n\n"}], "solutions": [{"file_name": "index.js", "content": "class Node {\n    constructor(value){\n        this.value = value;\n        this.next = null;\n    }\n}\n \nclass LinkedList {\n    constructor(value) {\n        const newNode = new Node(value);\n        this.head = newNode;\n        this.tail = this.head;\n        this.length = 1;\n    }\n\n    printList() {\n        let temp = this.head;\n        let output = \"\";\n        if (temp === null) {\n            console.log(\"empty\");\n            return;\n        }\n        while (temp !== null) {\n            output += String(temp.value);\n            temp = temp.next;\n            if (temp !== null) {\n                output += \" -> \";\n            }\n        }\n        console.log(output);\n    }\n\n    makeEmpty() {\n        this.head = null;\n        this.tail = null;\n        this.length = 0;\n    }\n    \n    push(value) {\n        const newNode = new Node(value);\n        if (!this.head) {\n            this.head = newNode;\n            this.tail = newNode;\n        } else {\n            this.tail.next = newNode;\n            this.tail = newNode;\n        }\n        this.length++;\n        return this;\n    }\n    \n    bubbleSort() {\n        if (this.length < 2) return;\n\n        let sortedUntil = null;\n        while (sortedUntil !== this.head.next) {\n            let current = this.head;\n            while (current.next !== sortedUntil) {\n                let nextNode = current.next;\n                if (current.value > nextNode.value) {\n                    const temp = current.value;\n                    current.value = nextNode.value;\n                    nextNode.value = temp;\n                }\n                current = current.next;\n            }\n            sortedUntil = current;\n        }\n    }\n\t\n}\n\n\n\n\n\n// ------------------------------------\n//  Sort descending list\n// ------------------------------------\nconst list1 = new LinkedList(4);\nlist1.push(3);\nlist1.push(2);\nlist1.push(1);\nconsole.log(\"Sort descending list:\");\nlist1.printList(); // Should print: 4 -> 3 -> 2 -> 1\nlist1.bubbleSort();\nlist1.printList(); // Should print: 1 -> 2 -> 3 -> 4\nconsole.log(\"---------------\");\n\n// ------------------------------------\n//  Sort already sorted list\n// ------------------------------------\nconst list2 = new LinkedList(1);\nlist2.push(2);\nconsole.log(\"Sort already sorted list:\");\nlist2.printList(); // Should print: 1 -> 2\nlist2.bubbleSort();\nlist2.printList(); // Should print: 1 -> 2\nconsole.log(\"---------------\");\n\n// ------------------------------------\n//  Sort list with random elements\n// ------------------------------------\nconst list3 = new LinkedList(3);\nlist3.push(1);\nlist3.push(4);\nlist3.push(2);\nconsole.log(\"Sort list with random elements:\");\nlist3.printList(); // Should print: 3 -> 1 -> 4 -> 2\nlist3.bubbleSort();\nlist3.printList(); // Should print: 1 -> 2 -> 3 -> 4\nconsole.log(\"---------------\");\n\n// ------------------------------------\n//  Sort list with duplicate elements\n// ------------------------------------\nconst list4 = new LinkedList(3);\nlist4.push(3);\nlist4.push(2);\nlist4.push(2);\nconsole.log(\"Sort list with duplicate elements:\");\nlist4.printList(); // Should print: 3 -> 3 -> 2 -> 2\nlist4.bubbleSort();\nlist4.printList(); // Should print: 2 -> 2 -> 3 -> 3\nconsole.log(\"---------------\");\n\n// ------------------------------------\n//  Sort single-element list\n// ------------------------------------\nconst list5 = new LinkedList(1);\nconsole.log(\"Sort single-element list:\");\nlist5.printList(); // Should print: 1\nlist5.bubbleSort();\nlist5.printList(); // Should print: 1\nconsole.log(\"---------------\");\n\n// ------------------------------------\n//  Sort list with negative numbers\n// ------------------------------------\nconst list6 = new LinkedList(-1);\nlist6.push(-2);\nlist6.push(1);\nconsole.log(\"Sort list with negative numbers:\");\nlist6.printList(); // Should print: -1 -> -2 -> 1\nlist6.bubbleSort();\nlist6.printList(); // Should print: -2 -> -1 -> 1\nconsole.log(\"---------------\");\n\n// ------------------------------------\n//  Sort list with zeros\n// ------------------------------------\nconst list7 = new LinkedList(0);\nlist7.push(0);\nlist7.push(1);\nconsole.log(\"Sort list with zeros:\");\nlist7.printList(); // Should print: 0 -> 0 -> 1\nlist7.bubbleSort();\nlist7.printList(); // Should print: 0 -> 0 -> 1\nconsole.log(\"---------------\");\n\n// ------------------------------------\n//  Sort empty list\n// ------------------------------------\nconst list8 = new LinkedList(1);\nlist8.makeEmpty();\nconsole.log(\"Sort empty list:\");\nlist8.printList(); // Should print: empty\nlist8.bubbleSort();\nlist8.printList(); // Should print: empty\nconsole.log(\"---------------\");\n\n\n\t"}]};

      function renderCodeList(rootElement, codeList, className, titlePrefix) {
        for (var i = 0; i < codeList.length; i++) {
          var elem = codeList[i];
          var jsElem = document.createElement("div");
          jsElem.className = className;
          var jsElemTitle = document.createElement("h3");
          jsElemTitle.innerHTML = titlePrefix + " " + (i + 1);
          var jsElemBody = document.createElement("code");
          jsElemBody.className = "code-block black-block";
          jsElemBody.innerHTML = "<pre>" + elem.content + "</pre>";
          jsElem.appendChild(jsElemTitle);
          jsElem.appendChild(jsElemBody);
          rootElement.appendChild(jsElem);
        }
      }
      
      function main() {
        // display the assignment
        var codingTitle = document.getElementById("coding-title");
        codingTitle.innerHTML = quizData.title;
        
        var codingInstructions = document.getElementById("coding-instructions");
        if (quizData.hasInstructions) {
          codingInstructions.innerHTML = quizData.instructions;
        } else {
          codingInstructions.innerHTML = "<span class=\"italic-text\">" + quizData.instructions
            + "</span>";
        }

        // display the test(s)
        var codingTests = document.getElementById("coding-tests");
        if (!quizData.hasTests) {
          codingTests.innerHTML = "<span class=\"italic-text\">" + quizData.tests + "</span>";
        } else {
          renderCodeList(codingTests, quizData.tests, "coding-test", "Test");
        }
        

        // display the solution(s)
        var codingSolutions = document.getElementById("coding-solutions");
        if (!quizData.hasSolutions) {
          codingSolutions.innerHTML = "<span class=\"italic-text\">" + quizData.solutions + "</span>";
        } else {
          renderCodeList(codingSolutions, quizData.solutions, "coding-solution", "Solution");
        }
      }
    </script>
  </body>
</html>
